let function_list = [];
class Function{
  constructor(name,nargs,instruction){
    this.name = name;
    this.nargs = nargs;
    this.instruction = instruction;
  }
}
function Create_functions(functions){
 //vazio por eqnt
  }                
class operator{
  
  constructor(token,precedence=1,associativity,type){
  this.token = token;
  this.precedence = precedence;
  this.associativity = associativity;
  this.type = type;
  }
}
function Create_operator(operators){
  operators.push(new operator("+",2,"left","dunary"));
  operators.push(new operator("-",2,"left","dunary"));
  operators.push(new operator("*",3,"left","dunary"));
  operators.push(new operator("/",3,"left","dunary"));
  operators.push(new operator("^",5,"right","dunary"));
  operators.push(new operator("'",5,"right","unary"));
  operators.push(new operator("%",4,"left","dunary"))
  operators.push(new operator("&",4,"right","unary"))
 }
   
function solve_expression(number1,number2,operator){
  switch (operator){
    case "+":
      return number1+number2
    case "-":
      return number1-number2
    case "*":
      return number2*number1;
    case "/":
      return number2/number1;
    case "^":
      return Math.pow(number1,number2);
    case "'":
      return -number2;
    case "%":
       return number1%number2;
    case "&":
       return number2+1000;
  }
}

function Main(){
  let operator_list=[];
  let test ;
  Create_operator(operator_list);
  let expression = "((90-10)*-(100*20+10*30)+++++++++++------------------++++++-40)+3%2*3^4*5+&20";
  
  //operador & criei só pra mostrar q da pra fazer qualquer magia aqui , no caso o & add 1000 no numero da frente(((90-10)*(100*20-300)-40)+3%2*3^4*5+1020). Com isso ja da pra criar expressão booleana facilmente.
  let array = expression.match(/[0-9]+|[A-Za-z0-9]+|\S/g);
  function get_precedence(operator_list,operator){
  for(let i=0; i<operator_list.length ; i++){
    if(operator==operator_list[i].token){
      return operator_list[i].precedence;
    }
  }
  return 0;
}
  function get_associativity(operator_list,operator){
    for(let i=0; i<operator_list.length ; i++){
    if(operator==operator_list[i].token){
      return operator_list[i].associativity;
    }
  }
  
}
  function get_operator_token(operator_list,token){
  for(let i=0; i<operator_list.length ; i++){
    if(token==operator_list[i].token){
      return operator_list[i].token;
    }
  }
  
}
  function get_operator_type(operator_list,operator){
    for(let  i=0 ; i<operator_list.length ; i++){
      if(operator_list[i].token == operator){
        
        return operator_list[i].type;
      }
    }
  }
  function identify(term){
  
  if(term==undefined){
    return undefined;
  }
  if(get_operator_token(operator_list,term)){
    return "operator";
  }
  if(term == "("){
    return "(";
  }
  if(term == ")"){
    return ")";
  }
  if(parseInt(term) | term=="0"){
    return "integer";
  }
   console.log(term)
  if(term.match(/^(".*")|('.*')$/)){
    
    return "string";
    
  }
  }
  function RPN(expression_array){
    
    let operator_stack = [];
    let output = [];
    let token;
    for(let i = 0 ; i <expression_array.length; i++ ){
      
      token = expression_array[i];
       if(token=="-" & identify(expression_array[i-1])=="operator")
        {
          expression_array.splice(i,1,"'")
          token = "'";
        }
      //no caso do 10--10 para ele reconhecer como unario o segundo menos e inverter o sinal do numero eu na hora de montar ele tenho que mudar o "-" que é unário por " ' ", a negação de discreta , porque desse modo eu consigo diferenciar na hora de resolver se ele é o operador unário ou o operador de subtração. 
      if(token=="+" & identify(expression_array[i-1])=="operator")
        {
          expression_array.splice(i,1,)
          i--;
          token = expression_array[i];
        }
  // caso de 10+++10 , eu não faço nada além deletar os + que não são operadores e no final obtenho 10+10 normalmente.
      if(identify(token)=="integer"){
        output.push(token);
      }
      else if(identify(token)=="function"){
        //operator_stack.push(new operator(token);
      }
      else if(identify(token)=="operator"){
        let stack_top = operator_stack[operator_stack.length-1];
        while((stack_top!=undefined) & ( get_precedence(operator_list,stack_top)>get_precedence(operator_list,token)
                                      | (get_precedence(operator_list,stack_top)==get_precedence(operator_list,token) & get_associativity(operator_list,token)=="left"))
                                       & (stack_top!="(")){
             
             output.push(operator_stack.pop());
             stack_top = operator_stack[operator_stack.length-1];
        }
        
        operator_stack.push(token);
      }

      else if(token=="("){
        operator_stack.push(token);
      }
      else if(token ==")"){
        let stack_top = operator_stack[operator_stack.length-1];
        while(stack_top!="("){
          output.push(operator_stack.pop());
          stack_top = operator_stack[operator_stack.length-1];
      }
        if(stack_top=="("){
          operator_stack.pop();
        }
      }  
    }
    for(let i=0;i<operator_stack.length;i++){
     if(identify(operator_stack[i])=="operator"){
        output.push(operator_stack.pop())
        i--;
      }
    }
    console.log(operator_stack);
    return output;
  } //passa pra reversed polish
  console.log(RPN(array));
  function solve_RPN(RPN_array){
    let result;
    let pos=0;
    let number2;
    while(RPN_array.length!=1){
      console.log(RPN_array);
      pos++
      while(identify(RPN_array[pos])!="operator"){
          result = RPN_array[pos-1];
          number2 = RPN_array[pos++];
          
        }
     
      result = solve_expression(parseInt(result,10),parseInt(number2,10),RPN_array[pos])
      console.log(result);
      if(get_operator_type(operator_list,RPN_array[pos])=="dunary"){
        RPN_array.splice(pos-2,3,result)
      }
     else{
       RPN_array.splice(pos-1,2,result)
     }
      pos=0;
    }
   return parseInt(RPN_array[0]); 
  } //resolve a expressão em reversed polish -> salvo dois numeros sempre e quando chega em um operador eu resolvo os dois numeros para o operador e depois removo os dois numeros que foram executados tal como o operador , caso o operador seja unario eu só altero o ultimo numero e o operador, por exemplo , 10+&10, vou operar o segundo numero somando 1000 nele, ou seja 10+1010.
  return solve_RPN(RPN(array));
}
console.log(Main());
